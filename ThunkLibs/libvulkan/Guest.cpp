/*
$info$
tags: thunklibs|Vulkan
$end_info$
*/

#define VK_USE_PLATFORM_XLIB_XRANDR_EXT
#define VK_USE_PLATFORM_XLIB_KHR
#define VK_USE_PLATFORM_XCB_KHR
#define VK_USE_PLATFORM_WAYLAND_KHR
#include <vulkan/vulkan.h>

#include "common/Guest.h"

#include <cstdio>
#include <dlfcn.h>
#include <functional>
#include <string_view>
#include <unordered_map>

#if 0
/******************************
 * COMMON DEFS FOLLOW
 *****************************/
template<typename PFM>
struct pfm_traits;
template<typename Parent, typename Data>
struct pfm_traits<Data Parent::*> {
    using parent_t = Parent;
    using member_t = Data;
};

using const_void_ptr = const void*;

/******************************
 * INTERFACE FOLLOWS
 *****************************/
template<typename>
struct fex_gen_type {};
namespace fexgen { struct custom_repack{}; }
template<>
struct fex_gen_type<VkImageCreateInfo> : fexgen::custom_repack {};

/******************************
 * MANUAL GEN FOLLOWS
 *****************************/

// Entities created by "use_custom_repack" annotation on VkImageCreateInfo and on &VkImageCreateInfo::pNext
void fexfn_destroy(VkImageCreateInfo& a);

template<auto PFM>
typename pfm_traits<decltype(PFM)>::member_t
fex_custom_repack(const typename pfm_traits<decltype(PFM)>::member_t& from);

template<>
const_void_ptr fex_custom_repack<&VkImageCreateInfo::pNext>(const const_void_ptr& from);

// Guest.h definitions

// Autogenerated
template<typename T>
struct fex_host_representation {
    T data;

    ~fex_host_representation() {
        fexfn_destroy(data);
    }
};

template<typename T>
using guest = T;

fex_host_representation<VkImageCreateInfo> Repack(const guest<VkImageCreateInfo>& from) {
  fex_host_representation<VkImageCreateInfo> to {};
  to.data.sType = from.sType;
  to.data.pNext = from.pNext;

  // Regular repacking for members after pNext
  to.data.flags = from.flags;
  to.data.imageType = from.imageType;
  to.data.format = from.format;
  to.data.extent = from.extent;
  to.data.mipLevels = from.mipLevels;
  to.data.arrayLayers = from.arrayLayers;
  to.data.samples = from.samples;
  to.data.tiling = from.tiling;
  to.data.usage = from.usage;
  to.data.sharingMode = from.sharingMode;
  to.data.queueFamilyIndexCount = from.queueFamilyIndexCount;
  to.data.pQueueFamilyIndices = from.pQueueFamilyIndices;
  to.data.initialLayout = from.initialLayout;

  to.data.pNext = fex_custom_repack<&VkImageCreateInfo::pNext>(from.pNext);

  return to;
}


VkResult fexfn_pack_vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    VkImage* pImage) {

    struct {
        // TODO: Need some magic to turn fex_host_rep<type*> into fex_host_rep<type>* ?
        fex_host_representation<VkDevice> device;
        fex_host_representation<VkImageCreateInfo>* pCreateInfo;
        fex_host_representation<VkImage*> pImage;
    } args;

//    args.device = Repack(device);
    auto tmp_pCreateInfo = Repack(*pCreateInfo);
    args.pCreateInfo = &tmp_pCreateInfo;

    auto result = fexthunks_vkCreateImage(&args);

    return result;

    // Implicitly runs fexfn_destroy via ~fex_host_representation() here
}


/******************************
 * ACTUAL MANUAL CODE FOLLOWS
 *****************************/

void fexfn_destroy(VkImageCreateInfo& data) {
    // Traverse pNext linked list and delete sub-structures
}

template<VkStructureType TypeIndex, typename Type>
const VkBaseInStructure* convert(const VkBaseInStructure* source) {
    auto child = new fex_host_representation<VkImageCreateInfo>; // TODO: Dynamically set the correct type based on source.sType
    *child = Repack(*reinterpret_cast<guest<VkImageCreateInfo>*>((void*)(source))); // TODO: Use proper cast?
    return (const VkBaseInStructure*)child; // TODO: Use proper cast?
}

std::unordered_map<VkStructureType, const VkBaseInStructure*(*)(const VkBaseInStructure*)> next_handlers {
    { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, convert<VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, VkImageCreateInfo> }
};

template<>
const_void_ptr fex_custom_repack<&VkImageCreateInfo::pNext>(const const_void_ptr& source) {
    if (!source) {
        return nullptr;
    }

    auto typed_source = reinterpret_cast<const VkBaseInStructure*>(source);
    auto child = next_handlers.at(typed_source->sType)(typed_source);
    return child;
}

#endif


#include "thunkgen_guest_libvulkan.inl"

extern "C" {

#if 0
// Maps Vulkan API function names to the address of a guest function which is
// linked to the corresponding host function pointer
const std::unordered_map<std::string_view, uintptr_t /* guest function address */> HostPtrInvokers =
    std::invoke([]() {
#define PAIR(name, unused) Ret[#name] = reinterpret_cast<uintptr_t>(GetCallerForHostFunction(name));
        std::unordered_map<std::string_view, uintptr_t> Ret;
        FOREACH_internal_SYMBOL(PAIR);
        return Ret;
#undef PAIR
    });

// This variable controls the behavior of vkGetDevice/InstanceProcAddr for functions we don't know the signature of:
// - if false (default), we return a nullptr (since the application might have a fallback code path)
// - if true, we return a stub function that fatally errors upon being called
constexpr bool stub_unknown_functions = false;

// Fatally erroring function with a thunk-like interface. This is used as a placeholder for unknown Vulkan functions
[[noreturn]] static void FatalError(void* raw_args) {
    auto called_function = reinterpret_cast<PackedArguments<void, uintptr_t>*>(raw_args)->a0;
    fprintf(stderr, "FATAL: Called unknown Vulkan function at address %p\n", reinterpret_cast<void*>(called_function));
    __builtin_trap();
}

static PFN_vkVoidFunction MakeGuestCallable(const char* origin, PFN_vkVoidFunction func, const char* name) {
    auto It = HostPtrInvokers.find(name);
    if (It == HostPtrInvokers.end()) {
        fprintf(stderr, "%s: Unknown Vulkan function at address %p: %s\n", origin, func, name);
        if (stub_unknown_functions) {
            const auto StubHostPtrInvoker = CallHostFunction<FatalError, void>;
            LinkAddressToFunction((uintptr_t)func, reinterpret_cast<uintptr_t>(StubHostPtrInvoker));
            return func;
        }
        return nullptr;
    }
    fprintf(stderr, "Linking address %p to host invoker %#zx\n", func, It->second);
    LinkAddressToFunction((uintptr_t)func, It->second);
    return func;
}

PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice a_0,const char* a_1){
    auto Ret = fexfn_pack_vkGetDeviceProcAddr(a_0, a_1);
    if (!Ret) {
        return nullptr;
    }
    return MakeGuestCallable(__FUNCTION__, Ret, a_1);
}

PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance a_0,const char* a_1){
    if (a_1 == std::string_view { "vkGetDeviceProcAddr" }) {
        return (PFN_vkVoidFunction)vkGetDeviceProcAddr;
    } else {
        auto Ret = fexfn_pack_vkGetInstanceProcAddr(a_0, a_1);
        if (!Ret) {
            return nullptr;
        }
        return MakeGuestCallable(__FUNCTION__, Ret, a_1);
    }
}

#endif
}
LOAD_LIB(libvulkan)
